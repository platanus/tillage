{
  "_args": [
    [
      "https://github.com/ztombol/bats-assert",
      "/opt/tillage/repo"
    ]
  ],
  "_from": "git+https://github.com/ztombol/bats-assert.git",
  "_id": "bats-assert@0.3.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/bats-assert",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/ztombol/bats-assert/master/package.json",
      "gitUrl": "git://github.com/ztombol/bats-assert.git",
      "httpsUrl": "git+https://github.com/ztombol/bats-assert.git",
      "shortcut": "github:ztombol/bats-assert",
      "ssh": "git@github.com:ztombol/bats-assert.git",
      "sshUrl": "git+ssh://git@github.com/ztombol/bats-assert.git",
      "type": "github"
    },
    "name": null,
    "raw": "https://github.com/ztombol/bats-assert",
    "rawSpec": "https://github.com/ztombol/bats-assert",
    "scope": null,
    "spec": "git+https://github.com/ztombol/bats-assert.git",
    "type": "hosted"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "git+https://github.com/ztombol/bats-assert.git#9f88b4207da750093baabc4e3f41bf68f0dd3630",
  "_shasum": "23928767c74f2df37a6bcbda789f0725d832e749",
  "_shrinkwrap": null,
  "_spec": "https://github.com/ztombol/bats-assert",
  "_where": "/opt/tillage/repo",
  "dependencies": {},
  "description": "[![GitHub license](https://img.shields.io/badge/license-CC0-blue.svg)](https://raw.githubusercontent.com/ztombol/bats-assert/master/LICENSE) [![GitHub release](https://img.shields.io/github/release/ztombol/bats-assert.svg)](https://github.com/ztombol/bats-assert/releases/latest) [![Build Status](https://travis-ci.org/ztombol/bats-assert.svg?branch=master)](https://travis-ci.org/ztombol/bats-assert)",
  "devDependencies": {},
  "gitHead": "9f88b4207da750093baabc4e3f41bf68f0dd3630",
  "name": "bats-assert",
  "optionalDependencies": {},
  "peerDependencies": {
    "bats-support": "git+https://github.com/ztombol/bats-support.git#v0.2.0"
  },
  "private": true,
  "readme": "# bats-assert\n\n[![GitHub license](https://img.shields.io/badge/license-CC0-blue.svg)](https://raw.githubusercontent.com/ztombol/bats-assert/master/LICENSE)\n[![GitHub release](https://img.shields.io/github/release/ztombol/bats-assert.svg)](https://github.com/ztombol/bats-assert/releases/latest)\n[![Build Status](https://travis-ci.org/ztombol/bats-assert.svg?branch=master)](https://travis-ci.org/ztombol/bats-assert)\n\n`bats-assert` is a helper library providing common assertions for\n[Bats][bats].\n\nAssertions are functions that perform a test and output relevant\ninformation on failure to help debugging. They return 1 on failure and 0\notherwise. Output, [formatted][bats-support-output] for readability, is\nsent to the standard error to make assertions usable outside of `@test`\nblocks too.\n\nAssertions testing exit code and output operate on the results of the\nmost recent invocation of `run`.\n\nDependencies:\n- [`bats-support`][bats-support] (formerly `bats-core`) - output\n  formatting\n\nSee the [shared documentation][bats-docs] to learn how to install and\nload this library.\n\n\n## Usage\n\n### `assert`\n\nFail if the given expression evaluates to false.\n\n***Note:*** *The expression must be a simple command. [Compound\ncommands][bash-comp-cmd], such as `[[`, can be used only when executed\nwith `bash -c`.*\n\n```bash\n@test 'assert()' {\n  touch '/var/log/test.log'\n  assert [ -e '/var/log/test.log' ]\n}\n```\n\nOn failure, the failed expression is displayed.\n\n```\n-- assertion failed --\nexpression : [ -e /var/log/test.log ]\n--\n```\n\n\n### `refute`\n\nFail if the given expression evaluates to true.\n\n***Note:*** *The expression must be a simple command. [Compound\ncommands][bash-comp-cmd], such as `[[`, can be used only when executed\nwith `bash -c`.*\n\n```bash\n@test 'refute()' {\n  rm -f '/var/log/test.log'\n  refute [ -e '/var/log/test.log' ]\n}\n```\n\nOn failure, the successful expression is displayed.\n\n```\n-- assertion succeeded, but it was expected to fail --\nexpression : [ -e /var/log/test.log ]\n--\n```\n\n\n### `assert_equal`\n\nFail if the two parameters, actual and expected value respectively, do\nnot equal.\n\n```bash\n@test 'assert_equal()' {\n  assert_equal 'have' 'want'\n}\n```\n\nOn failure, the expected and actual values are displayed.\n\n```\n-- values do not equal --\nexpected : want\nactual   : have\n--\n```\n\nIf either value is longer than one line both are displayed in\n*multi-line* format.\n\n\n### `assert_success`\n\nFail if `$status` is not 0.\n\n```bash\n@test 'assert_success() status only' {\n  run bash -c \"echo 'Error!'; exit 1\"\n  assert_success\n}\n```\n\nOn failure, `$status` and `$output` are displayed.\n\n```\n-- command failed --\nstatus : 1\noutput : Error!\n--\n```\n\nIf `$output` is longer than one line, it is displayed in *multi-line*\nformat.\n\n\n### `assert_failure`\n\nFail if `$status` is 0.\n\n```bash\n@test 'assert_failure() status only' {\n  run echo 'Success!'\n  assert_failure\n}\n```\n\nOn failure, `$output` is displayed.\n\n```\n-- command succeeded, but it was expected to fail --\noutput : Success!\n--\n```\n\nIf `$output` is longer than one line, it is displayed in *multi-line*\nformat.\n\n#### Expected status\n\nWhen one parameter is specified, fail if `$status` does not equal the\nexpected status specified by the parameter.\n\n```bash\n@test 'assert_failure() with expected status' {\n  run bash -c \"echo 'Error!'; exit 1\"\n  assert_failure 2\n}\n```\n\nOn failure, the expected and actual status, and `$output` are displayed.\n\n```\n-- command failed as expected, but status differs --\nexpected : 2\nactual   : 1\noutput   : Error!\n--\n```\n\nIf `$output` is longer than one line, it is displayed in *multi-line*\nformat.\n\n\n### `assert_output`\n\nThis function helps to verify that a command or function produces the\ncorrect output by checking that the specified expected output matches\nthe actual output. Matching can be literal (default), partial or regular\nexpression. This function is the logical complement of `refute_output`.\n\n#### Literal matching\n\nBy default, literal matching is performed. The assertion fails if\n`$output` does not equal the expected output.\n\n```bash\n@test 'assert_output()' {\n  run echo 'have'\n  assert_output 'want'\n}\n```\n\nThe expected output can be specified with a heredoc or standard input as well.\n\n```bash\n@test 'assert_output() with pipe' {\n  run echo 'have'\n  echo 'want' | assert_output\n}\n```\n\nOn failure, the expected and actual output are displayed.\n\n```\n-- output differs --\nexpected : want\nactual   : have\n--\n```\n\nIf either value is longer than one line both are displayed in\n*multi-line* format.\n\n#### Partial matching\n\nPartial matching can be enabled with the `--partial` option (`-p` for\nshort). When used, the assertion fails if the expected *substring* is\nnot found in `$output`.\n\n```bash\n@test 'assert_output() partial matching' {\n  run echo 'ERROR: no such file or directory'\n  assert_output --partial 'SUCCESS'\n}\n```\n\nOn failure, the substring and the output are displayed.\n\n```\n-- output does not contain substring --\nsubstring : SUCCESS\noutput    : ERROR: no such file or directory\n--\n```\n\nThis option and regular expression matching (`--regexp` or `-e`) are\nmutually exclusive. An error is displayed when used simultaneously.\n\n#### Regular expression matching\n\nRegular expression matching can be enabled with the `--regexp` option\n(`-e` for short). When used, the assertion fails if the *extended\nregular expression* does not match `$output`.\n\n*Note: The anchors `^` and `$` bind to the beginning and the end of the\nentire output (not individual lines), respectively.*\n\n```bash\n@test 'assert_output() regular expression matching' {\n  run echo 'Foobar 0.1.0'\n  assert_output --regexp '^Foobar v[0-9]+\\.[0-9]+\\.[0-9]$'\n}\n```\n\nOn failure, the regular expression and the output are displayed.\n\n```\n-- regular expression does not match output --\nregexp : ^Foobar v[0-9]+\\.[0-9]+\\.[0-9]$\noutput : Foobar 0.1.0\n--\n```\n\nAn error is displayed if the specified extended regular expression is\ninvalid.\n\nThis option and partial matching (`--partial` or `-p`) are mutually\nexclusive. An error is displayed when used simultaneously.\n\n\n### `refute_output`\n\nThis function helps to verify that a command or function produces the\ncorrect output by checking that the specified unexpected output does not\nmatch the actual output. Matching can be literal (default), partial or\nregular expression. This function is the logical complement of\n`assert_output`.\n\n#### Literal matching\n\nBy default, literal matching is performed. The assertion fails if\n`$output` equals the unexpected output.\n\n```bash\n@test 'refute_output()' {\n  run echo 'want'\n  refute_output 'want'\n}\n```\n\n-The unexpected output can be specified with a heredoc or standard input as well.\n\n```bash\n@test 'refute_output() with pipe' {\n  run echo 'want'\n  echo 'want' | refute_output\n}\n```\n\nOn failure, the output is displayed.\n\n```\n-- output equals, but it was expected to differ --\noutput : want\n--\n```\n\nIf output is longer than one line it is displayed in *multi-line*\nformat.\n\n#### Partial matching\n\nPartial matching can be enabled with the `--partial` option (`-p` for\nshort). When used, the assertion fails if the unexpected *substring* is\nfound in `$output`.\n\n```bash\n@test 'refute_output() partial matching' {\n  run echo 'ERROR: no such file or directory'\n  refute_output --partial 'ERROR'\n}\n```\n\nOn failure, the substring and the output are displayed.\n\n```\n-- output should not contain substring --\nsubstring : ERROR\noutput    : ERROR: no such file or directory\n--\n```\n\nThis option and regular expression matching (`--regexp` or `-e`) are\nmutually exclusive. An error is displayed when used simultaneously.\n\n#### Regular expression matching\n\nRegular expression matching can be enabled with the `--regexp` option\n(`-e` for short). When used, the assertion fails if the *extended\nregular expression* matches `$output`.\n\n*Note: The anchors `^` and `$` bind to the beginning and the end of the\nentire output (not individual lines), respectively.*\n\n```bash\n@test 'refute_output() regular expression matching' {\n  run echo 'Foobar v0.1.0'\n  refute_output --regexp '^Foobar v[0-9]+\\.[0-9]+\\.[0-9]$'\n}\n```\n\nOn failure, the regular expression and the output are displayed.\n\n```\n-- regular expression should not match output --\nregexp : ^Foobar v[0-9]+\\.[0-9]+\\.[0-9]$\noutput : Foobar v0.1.0\n--\n```\n\nAn error is displayed if the specified extended regular expression is\ninvalid.\n\nThis option and partial matching (`--partial` or `-p`) are mutually\nexclusive. An error is displayed when used simultaneously.\n\n\n### `assert_line`\n\nSimilarly to `assert_output`, this function helps to verify that a\ncommand or function produces the correct output. It checks that the\nexpected line appears in the output (default) or in a specific line of\nit. Matching can be literal (default), partial or regular expression.\nThis function is the logical complement of `refute_line`.\n\n***Warning:*** *Due to a [bug in Bats][bats-93], empty lines are\ndiscarded from `${lines[@]}`, causing line indices to change and\npreventing testing for empty lines.*\n\n[bats-93]: https://github.com/sstephenson/bats/pull/93\n\n#### Looking for a line in the output\n\nBy default, the entire output is searched for the expected line. The\nassertion fails if the expected line is not found in `${lines[@]}`.\n\n```bash\n@test 'assert_line() looking for line' {\n  run echo $'have-0\\nhave-1\\nhave-2'\n  assert_line 'want'\n}\n```\n\nOn failure, the expected line and the output are displayed.\n\n***Warning:*** *The output displayed does not contain empty lines. See\nthe Warning above for more.*\n\n```\n-- output does not contain line --\nline : want\noutput (3 lines):\n  have-0\n  have-1\n  have-2\n--\n```\n\nIf output is not longer than one line, it is displayed in *two-column*\nformat.\n\n#### Matching a specific line\n\nWhen the `--index <idx>` option is used (`-n <idx>` for short) , the\nexpected line is matched only against the line identified by the given\nindex. The assertion fails if the expected line does not equal\n`${lines[<idx>]}`.\n\n```bash\n@test 'assert_line() specific line' {\n  run echo $'have-0\\nhave-1\\nhave-2'\n  assert_line --index 1 'want-1'\n}\n```\n\nOn failure, the index and the compared lines are displayed.\n\n```\n-- line differs --\nindex    : 1\nexpected : want-1\nactual   : have-1\n--\n```\n\n#### Partial matching\n\nPartial matching can be enabled with the `--partial` option (`-p` for\nshort). When used, a match fails if the expected *substring* is not\nfound in the matched line.\n\n```bash\n@test 'assert_line() partial matching' {\n  run echo $'have 1\\nhave 2\\nhave 3'\n  assert_line --partial 'want'\n}\n```\n\nOn failure, the same details are displayed as for literal matching,\nexcept that the substring replaces the expected line.\n\n```\n-- no output line contains substring --\nsubstring : want\noutput (3 lines):\n  have 1\n  have 2\n  have 3\n--\n```\n\nThis option and regular expression matching (`--regexp` or `-e`) are\nmutually exclusive. An error is displayed when used simultaneously.\n\n#### Regular expression matching\n\nRegular expression matching can be enabled with the `--regexp` option\n(`-e` for short). When used, a match fails if the *extended regular\nexpression* does not match the line being tested.\n\n*Note: As expected, the anchors `^` and `$` bind to the beginning and\nthe end of the matched line, respectively.*\n\n```bash\n@test 'assert_line() regular expression matching' {\n  run echo $'have-0\\nhave-1\\nhave-2'\n  assert_line --index 1 --regexp '^want-[0-9]$'\n}\n```\n\nOn failure, the same details are displayed as for literal matching,\nexcept that the regular expression replaces the expected line.\n\n```\n-- regular expression does not match line --\nindex  : 1\nregexp : ^want-[0-9]$\nline   : have-1\n--\n```\n\nAn error is displayed if the specified extended regular expression is\ninvalid.\n\nThis option and partial matching (`--partial` or `-p`) are mutually\nexclusive. An error is displayed when used simultaneously.\n\n\n### `refute_line`\n\nSimilarly to `refute_output`, this function helps to verify that a\ncommand or function produces the correct output. It checks that the\nunexpected line does not appear in the output (default) or in a specific\nline of it. Matching can be literal (default), partial or regular\nexpression. This function is the logical complement of `assert_line`.\n\n***Warning:*** *Due to a [bug in Bats][bats-93], empty lines are\ndiscarded from `${lines[@]}`, causing line indices to change and\npreventing testing for empty lines.*\n\n[bats-93]: https://github.com/sstephenson/bats/pull/93\n\n#### Looking for a line in the output\n\nBy default, the entire output is searched for the unexpected line. The\nassertion fails if the unexpected line is found in `${lines[@]}`.\n\n```bash\n@test 'refute_line() looking for line' {\n  run echo $'have-0\\nwant\\nhave-2'\n  refute_line 'want'\n}\n```\n\nOn failure, the unexpected line, the index of its first match and the\noutput with the matching line highlighted are displayed.\n\n***Warning:*** *The output displayed does not contain empty lines. See\nthe Warning above for more.*\n\n```\n-- line should not be in output --\nline  : want\nindex : 1\noutput (3 lines):\n  have-0\n> want\n  have-2\n--\n```\n\nIf output is not longer than one line, it is displayed in *two-column*\nformat.\n\n#### Matching a specific line\n\nWhen the `--index <idx>` option is used (`-n <idx>` for short) , the\nunexpected line is matched only against the line identified by the given\nindex. The assertion fails if the unexpected line equals\n`${lines[<idx>]}`.\n\n```bash\n@test 'refute_line() specific line' {\n  run echo $'have-0\\nwant-1\\nhave-2'\n  refute_line --index 1 'want-1'\n}\n```\n\nOn failure, the index and the unexpected line are displayed.\n\n```\n-- line should differ --\nindex : 1\nline  : want-1\n--\n```\n\n#### Partial matching\n\nPartial matching can be enabled with the `--partial` option (`-p` for\nshort). When used, a match fails if the unexpected *substring* is found\nin the matched line.\n\n```bash\n@test 'refute_line() partial matching' {\n  run echo $'have 1\\nwant 2\\nhave 3'\n  refute_line --partial 'want'\n}\n```\n\nOn failure, in addition to the details of literal matching, the\nsubstring is also displayed. When used with `--index <idx>` the\nsubstring replaces the unexpected line.\n\n```\n-- no line should contain substring --\nsubstring : want\nindex     : 1\noutput (3 lines):\n  have 1\n> want 2\n  have 3\n--\n```\n\nThis option and regular expression matching (`--regexp` or `-e`) are\nmutually exclusive. An error is displayed when used simultaneously.\n\n#### Regular expression matching\n\nRegular expression matching can be enabled with the `--regexp` option\n(`-e` for short). When used, a match fails if the *extended regular\nexpression* matches the line being tested.\n\n*Note: As expected, the anchors `^` and `$` bind to the beginning and\nthe end of the matched line, respectively.*\n\n```bash\n@test 'refute_line() regular expression matching' {\n  run echo $'Foobar v0.1.0\\nRelease date: 2015-11-29'\n  refute_line --index 0 --regexp '^Foobar v[0-9]+\\.[0-9]+\\.[0-9]$'\n}\n```\n\nOn failure, in addition to the details of literal matching, the regular\nexpression is also displayed. When used with `--index <idx>` the regular\nexpression replaces the unexpected line.\n\n```\n-- regular expression should not match line --\nindex  : 0\nregexp : ^Foobar v[0-9]+\\.[0-9]+\\.[0-9]$\nline   : Foobar v0.1.0\n--\n```\n\nAn error is displayed if the specified extended regular expression is\ninvalid.\n\nThis option and partial matching (`--partial` or `-p`) are mutually\nexclusive. An error is displayed when used simultaneously.\n\n\n## Options\n\nFor functions that have options, `--` disables option parsing for the\nremaining arguments to allow using arguments identical to one of the\nallowed options.\n\n```bash\nassert_output -- '-p'\n```\n\nSpecifying `--` as an argument is similarly simple.\n\n```bash\nrefute_line -- '--'\n```\n\n\n<!-- REFERENCES -->\n\n[bats]: https://github.com/sstephenson/bats\n[bats-support-output]: https://github.com/ztombol/bats-support#output-formatting\n[bats-support]: https://github.com/ztombol/bats-support\n[bats-docs]: https://github.com/ztombol/bats-docs\n[bash-comp-cmd]: https://www.gnu.org/software/bash/manual/bash.html#Compound-Commands\n",
  "readmeFilename": "README.md",
  "version": "0.3.0"
}
